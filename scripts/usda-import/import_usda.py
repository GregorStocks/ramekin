#!/usr/bin/env python3
"""
Import ingredient densities from USDA FoodData Central.

Downloads Foundation Foods data and extracts grams-per-cup for each ingredient,
then generates an updated density_data.rs file.

Usage:
    uv run import_usda.py [--output density_data.rs]
"""

import csv
from pathlib import Path
from collections import defaultdict

# Volume measure unit IDs from USDA
CUP_UNIT_ID = "1000"
TBSP_UNIT_ID = "1001"
TSP_UNIT_ID = "1002"

# Conversion factors to cups
TBSP_PER_CUP = 16.0
TSP_PER_CUP = 48.0


def load_csv(path: Path) -> list[dict]:
    """Load a CSV file and return list of dicts."""
    with open(path, "r", encoding="utf-8") as f:
        return list(csv.DictReader(f))


def extract_ingredient_key(description: str) -> str | None:
    """
    Extract ingredient key from USDA description.
    Returns lowercase name, or None if empty.
    """
    name = description.lower().strip()
    if not name:
        return None
    return name


def calculate_grams_per_cup(portions: list[dict]) -> float | None:
    """
    Calculate grams per cup from portion data.
    Prefers direct cup measurements, falls back to tbsp/tsp conversions.
    """
    cup_weights = []
    tbsp_weights = []
    tsp_weights = []

    for p in portions:
        unit_id = p.get("measure_unit_id", "")
        try:
            amount = float(p.get("amount", 0))
            gram_weight = float(p.get("gram_weight", 0))
        except (ValueError, TypeError):
            continue

        if amount <= 0 or gram_weight <= 0:
            continue

        # Calculate grams per single unit
        grams_per_unit = gram_weight / amount

        if unit_id == CUP_UNIT_ID:
            cup_weights.append(grams_per_unit)
        elif unit_id == TBSP_UNIT_ID:
            # Convert tbsp to cup equivalent
            tbsp_weights.append(grams_per_unit * TBSP_PER_CUP)
        elif unit_id == TSP_UNIT_ID:
            # Convert tsp to cup equivalent
            tsp_weights.append(grams_per_unit * TSP_PER_CUP)

    # Prefer cup measurements, then tbsp, then tsp
    if cup_weights:
        return sum(cup_weights) / len(cup_weights)
    elif tbsp_weights:
        return sum(tbsp_weights) / len(tbsp_weights)
    elif tsp_weights:
        return sum(tsp_weights) / len(tsp_weights)

    return None


def generate_rust_density_data(ingredients: dict[str, float]) -> str:
    """Generate the Rust density_data.rs file content."""

    # Sort by name for consistent output
    sorted_ingredients = sorted(ingredients.items(), key=lambda x: x[0])

    lines = []
    lines.append("//! Ingredient density data for volume-to-weight conversion.")
    lines.append("//!")
    lines.append("//! Densities are stored as grams per US cup (236.588 ml).")
    lines.append("//! Data sourced from USDA FoodData Central (public domain, CC0).")
    lines.append("//! Generated by scripts/usda-import/import_usda.py")
    lines.append("")
    lines.append("use std::collections::HashMap;")
    lines.append("use std::sync::LazyLock;")
    lines.append("")
    lines.append(
        "/// Volume conversion factors to cups (the reference unit for density data)."
    )
    lines.append("pub const CUPS_PER_TBSP: f64 = 1.0 / 16.0;")
    lines.append("pub const CUPS_PER_TSP: f64 = 1.0 / 48.0;")
    lines.append("pub const CUPS_PER_FL_OZ: f64 = 1.0 / 8.0;")
    lines.append("pub const CUPS_PER_PINT: f64 = 2.0;")
    lines.append("pub const CUPS_PER_QUART: f64 = 4.0;")
    lines.append("pub const CUPS_PER_GALLON: f64 = 16.0;")
    lines.append("pub const CUPS_PER_ML: f64 = 1.0 / 236.588;")
    lines.append("pub const CUPS_PER_L: f64 = 1000.0 / 236.588;")
    lines.append("")
    lines.append("/// Ingredient density data: canonical name -> grams per cup.")
    lines.append(
        "pub static DENSITY_DATA: LazyLock<HashMap<&'static str, f64>> "
        "= LazyLock::new(|| {"
    )
    lines.append("    let mut m = HashMap::new();")
    lines.append("")

    for name, grams in sorted_ingredients:
        # Escape any quotes in the name
        escaped_name = name.replace('"', '\\"')
        lines.append(f'    m.insert("{escaped_name}", {grams:.1f});')

    lines.append("")
    lines.append("    m")
    lines.append("});")
    lines.append("")

    # Generate aliases section
    lines.append("/// Aliases mapping common ingredient names to canonical names.")
    lines.append(
        "pub static INGREDIENT_ALIASES: "
        "LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {"
    )
    lines.append("    let mut m = HashMap::new();")
    lines.append("")

    # Add common aliases (from curated list)
    aliases = get_curated_aliases()
    for alias, canonical in sorted(aliases.items()):
        lines.append(f'    m.insert("{alias}", "{canonical}");')

    lines.append("")
    lines.append("    m")
    lines.append("});")
    lines.append("")

    # Add the rest of the module (modifiers, functions, tests)
    lines.append(RUST_MODULE_SUFFIX)

    return "\n".join(lines)


RUST_MODULE_SUFFIX = """\
/// Common modifiers to strip from ingredient names before matching.
const MODIFIERS_TO_STRIP: &[&str] = &[
    // Temperature/state modifiers (prefix)
    "room temperature ",
    "cold ",
    "warm ",
    "melted ",
    "softened ",
    // Preparation modifiers (suffix)
    ", softened",
    ", melted",
    ", cold",
    ", at room temperature",
    ", room temperature",
    ", chilled",
    ", sifted",
];

/// Convert a volume unit to its equivalent in cups.
pub fn volume_to_cups(amount: f64, unit: &str) -> Option<f64> {
    match unit {
        "cup" => Some(amount),
        "tbsp" => Some(amount * CUPS_PER_TBSP),
        "tsp" => Some(amount * CUPS_PER_TSP),
        "fl oz" => Some(amount * CUPS_PER_FL_OZ),
        "pint" => Some(amount * CUPS_PER_PINT),
        "quart" => Some(amount * CUPS_PER_QUART),
        "gallon" => Some(amount * CUPS_PER_GALLON),
        "ml" => Some(amount * CUPS_PER_ML),
        "l" => Some(amount * CUPS_PER_L),
        _ => None,
    }
}

/// Check if a unit is a volume unit we can convert.
pub fn is_volume_unit(unit: Option<&str>) -> bool {
    matches!(
        unit,
        Some("cup")
            | Some("tbsp")
            | Some("tsp")
            | Some("fl oz")
            | Some("pint")
            | Some("quart")
            | Some("gallon")
            | Some("ml")
            | Some("l")
    )
}

/// Find the density (grams per cup) for an ingredient name.
///
/// Tries:
/// 1. Direct lookup in DENSITY_DATA
/// 2. Lookup via INGREDIENT_ALIASES
/// 3. After stripping common modifiers, retry both lookups
pub fn find_density(ingredient_item: &str) -> Option<f64> {
    let normalized = normalize_ingredient_name(ingredient_item);

    // Direct lookup
    if let Some(&density) = DENSITY_DATA.get(normalized.as_str()) {
        return Some(density);
    }

    // Alias lookup
    if let Some(&canonical) = INGREDIENT_ALIASES.get(normalized.as_str()) {
        if let Some(&density) = DENSITY_DATA.get(canonical) {
            return Some(density);
        }
    }

    // Try with modifiers stripped
    let stripped = strip_modifiers(&normalized);
    if stripped != normalized {
        if let Some(&density) = DENSITY_DATA.get(stripped.as_str()) {
            return Some(density);
        }
        if let Some(&canonical) = INGREDIENT_ALIASES.get(stripped.as_str()) {
            if let Some(&density) = DENSITY_DATA.get(canonical) {
                return Some(density);
            }
        }
    }

    None
}

/// Normalize ingredient name for matching.
fn normalize_ingredient_name(s: &str) -> String {
    s.to_lowercase().trim().to_string()
}

/// Strip common modifiers from ingredient name.
fn strip_modifiers(s: &str) -> String {
    let mut result = s.to_string();
    for modifier in MODIFIERS_TO_STRIP {
        if let Some(stripped) = result.strip_prefix(modifier) {
            result = stripped.to_string();
        }
        if let Some(stripped) = result.strip_suffix(modifier) {
            result = stripped.to_string();
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_density_direct() {
        // These should find densities (exact names from USDA)
        assert!(find_density("cheese, cheddar").is_some());
    }

    #[test]
    fn test_find_density_alias() {
        // Common aliases should work
        assert!(find_density("flour").is_some());
        assert!(find_density("sugar").is_some());
        assert!(find_density("butter").is_some());
    }

    #[test]
    fn test_find_density_with_modifiers() {
        assert!(find_density("softened butter").is_some());
        assert!(find_density("melted butter").is_some());
    }

    #[test]
    fn test_find_density_case_insensitive() {
        assert!(find_density("FLOUR").is_some());
        assert!(find_density("Butter").is_some());
    }

    #[test]
    fn test_find_density_unknown() {
        assert_eq!(find_density("unicorn tears"), None);
        assert_eq!(find_density("mystery powder"), None);
    }

    #[test]
    fn test_volume_to_cups() {
        assert_eq!(volume_to_cups(1.0, "cup"), Some(1.0));
        assert_eq!(volume_to_cups(16.0, "tbsp"), Some(1.0));
        assert_eq!(volume_to_cups(48.0, "tsp"), Some(1.0));
        assert_eq!(volume_to_cups(8.0, "fl oz"), Some(1.0));
        assert_eq!(volume_to_cups(0.5, "pint"), Some(1.0));
    }

    #[test]
    fn test_is_volume_unit() {
        assert!(is_volume_unit(Some("cup")));
        assert!(is_volume_unit(Some("tbsp")));
        assert!(is_volume_unit(Some("tsp")));
        assert!(!is_volume_unit(Some("oz")));
        assert!(!is_volume_unit(Some("lb")));
        assert!(!is_volume_unit(Some("g")));
        assert!(!is_volume_unit(None));
    }
}
"""


def get_curated_ingredients() -> dict[str, float]:
    """
    Return curated ingredient densities for common baking ingredients.
    These are not well-covered by USDA Foundation Foods data.
    Sources: King Arthur Baking weight chart, various baking references.
    """
    return {
        # Flours (grams per cup)
        "all-purpose flour": 125.0,
        "bread flour": 127.0,
        "cake flour": 114.0,
        "whole wheat flour": 120.0,
        "almond flour": 96.0,
        "coconut flour": 112.0,
        # Sugars
        "granulated sugar": 200.0,
        "brown sugar": 220.0,  # packed
        "powdered sugar": 120.0,
        "honey": 340.0,
        "maple syrup": 315.0,
        # Dairy
        "butter": 227.0,
        "milk": 245.0,
        "heavy cream": 238.0,
        "sour cream": 242.0,
        "cream cheese": 232.0,
        # Fats/Oils
        "vegetable oil": 218.0,
        "olive oil": 216.0,
        "coconut oil": 218.0,
        # Other common
        "rolled oats": 80.0,
        "cornstarch": 128.0,
        "cocoa powder": 86.0,
        "peanut butter": 258.0,
    }


def get_curated_aliases() -> dict[str, str]:
    """Return curated aliases for common ingredient names."""
    return {
        # Flour aliases
        "flour": "all-purpose flour",
        "ap flour": "all-purpose flour",
        "plain flour": "all-purpose flour",
        "white flour": "all-purpose flour",
        # Sugar aliases
        "sugar": "granulated sugar",
        "white sugar": "granulated sugar",
        "caster sugar": "granulated sugar",
        "confectioners sugar": "powdered sugar",
        "confectioners' sugar": "powdered sugar",
        "icing sugar": "powdered sugar",
        "light brown sugar": "brown sugar",
        "dark brown sugar": "brown sugar",
        "packed brown sugar": "brown sugar",
        # Butter aliases
        "unsalted butter": "butter",
        "salted butter": "butter",
        # Oil aliases
        "oil": "vegetable oil",
        "canola oil": "vegetable oil",
        "extra virgin olive oil": "olive oil",
        "extra-virgin olive oil": "olive oil",
        # Cream aliases
        "whipping cream": "heavy cream",
        "heavy whipping cream": "heavy cream",
        "double cream": "heavy cream",
        "whole milk": "milk",
        # Oats aliases
        "oats": "rolled oats",
        "old-fashioned oats": "rolled oats",
        "old fashioned oats": "rolled oats",
        # Other aliases
        "corn starch": "cornstarch",
        "unsweetened cocoa powder": "cocoa powder",
        "dutch process cocoa powder": "cocoa powder",
        "natural cocoa powder": "cocoa powder",
        "pure maple syrup": "maple syrup",
    }


def main():
    script_dir = Path(__file__).parent
    data_dir = script_dir / "FoodData_Central_foundation_food_csv_2024-10-31"

    # Start with curated ingredients
    print("Loading curated ingredients...")
    ingredients = get_curated_ingredients()
    print(f"  {len(ingredients)} curated ingredients")

    print("\nLoading USDA data...")

    # Load food descriptions
    foods = load_csv(data_dir / "food.csv")
    food_map = {f["fdc_id"]: f["description"] for f in foods}
    print(f"  Loaded {len(food_map)} foods")

    # Load portions
    portions = load_csv(data_dir / "food_portion.csv")
    print(f"  Loaded {len(portions)} portion records")

    # Group portions by food
    portions_by_food = defaultdict(list)
    for p in portions:
        portions_by_food[p["fdc_id"]].append(p)

    # Calculate grams per cup for each food from USDA
    print("\nExtracting USDA densities...")
    usda_count = 0
    skipped_no_volume = 0
    skipped_bad_name = 0

    for fdc_id, food_portions in portions_by_food.items():
        description = food_map.get(fdc_id, "")
        if not description:
            continue

        # Extract clean ingredient name
        key = extract_ingredient_key(description)
        if not key:
            skipped_bad_name += 1
            continue

        # Calculate grams per cup
        grams_per_cup = calculate_grams_per_cup(food_portions)
        if grams_per_cup is None:
            skipped_no_volume += 1
            continue

        # Use the original description as the key (lowercase)
        canonical_name = description.lower()

        # Add USDA data (don't overwrite curated data)
        if canonical_name not in ingredients:
            ingredients[canonical_name] = grams_per_cup
            usda_count += 1

    print(f"  Added {usda_count} ingredients from USDA")
    print(f"  Skipped {skipped_no_volume} foods without volume measurements")
    print(f"  Skipped {skipped_bad_name} foods with unsuitable names")

    # Generate Rust code
    print("\nGenerating Rust code...")
    rust_code = generate_rust_density_data(ingredients)

    output_path = script_dir.parent.parent / "ramekin-core" / "src" / "density_data.rs"
    output_path.write_text(rust_code)
    print(f"  Written to {output_path}")

    # Print some stats
    print("\nDensity data summary:")
    print(f"  Total ingredients: {len(ingredients)}")

    # Show some examples
    print("\nSample entries:")
    for name, grams in sorted(ingredients.items())[:10]:
        print(f"  {name}: {grams:.1f} g/cup")


if __name__ == "__main__":
    main()
