//
// Ingredient.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Ingredient structure for JSONB storage */
public struct Ingredient: Codable, JSONEncodable, Hashable {

    /** The ingredient name (e.g., \"butter\", \"all-purpose flour\") */
    public var item: String
    /** Measurements - first is primary, rest are alternatives (e.g., \"1 stick\" then \"113g\") */
    public var measurements: [Measurement]
    /** Preparation notes (e.g., \"chopped\", \"softened\", \"optional\") */
    public var note: String?
    /** Original unparsed text for debugging */
    public var raw: String?
    /** Section name for grouping (e.g., \"For the sauce\", \"For the dough\") */
    public var section: String?

    public init(item: String, measurements: [Measurement], note: String? = nil, raw: String? = nil, section: String? = nil) {
        self.item = item
        self.measurements = measurements
        self.note = note
        self.raw = raw
        self.section = section
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case item
        case measurements
        case note
        case raw
        case section
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(item, forKey: .item)
        try container.encode(measurements, forKey: .measurements)
        try container.encodeIfPresent(note, forKey: .note)
        try container.encodeIfPresent(raw, forKey: .raw)
        try container.encodeIfPresent(section, forKey: .section)
    }
}

